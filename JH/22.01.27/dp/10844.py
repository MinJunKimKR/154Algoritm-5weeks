# dp는 점화식, 규칙을 잘 찾아야 한다...
# 배열 생성: [자리수][맨 앞 숫자]
# n=3 자리수까지 규칙을 찾아보면 앞 자리수와 -1, +1 자리수
  # 사이에 규칙을 찾을 수 있다. 
  # 만약 중복을 허용하지 않는다면 조금 다를 것 같지만. 

n = int(input())
dp = [ [0]*10 for _ in range(n+1)]
# cd = [[0]*10] * (n+1) #왜 이건 에러날까???
dp[1] = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1]

MOD = 1000000000
for i in range(2, n+1):
  for j in range(10):
    if j == 0:
      dp[i][j] = dp[i-1][1] 
      # 의미 없는 숫자 (나중에 더해지는데 사용)
    elif j == 9:
      dp[i][j] = dp[i-1][8]
    else:
       dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]

print( sum(dp[n]) % MOD)

